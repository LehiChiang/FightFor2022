## 第9章 集合

### 9.1 Java集合框架

#### 9.1.1 将集合的接口与实现分离

与现代的数据结构类库的常见情况一样，Java集合类库也将`接口(interface)`与`实现(implementation)`分离。

为什么要这样做？因为根据`接口(interface)`的本质来讲，接口中应抽象出实现类的服务。比如，`队列(Queue)`这个接口中指出可以在队列的尾部添加元素，在队列的头部删除元素，等等。我们抽象出的队列接口最简单的形式会类似于下面这样：

```java
public interface Queue<E> extends Collection<E> {
    boolean add(E var1);
    boolean offer(E var1);
    E remove();
    E poll();
    E element();
    E peek();
}
```

对于`实现(implementation)`来讲，队列通常有两种是实现方式：一种是使用循环数组；另一种是使用链表。这就是接口与实现在概念上的不同。不同方式实现的队列都会有队列接口中的方法。下面的例子使用两种方式实现队列功能。

```java
public class CircularArrayQueue<E>implements Queue<E> //not an actual library class
{
    private int head;
    private int tail;
    CircularArrayQueue(int capacity) { . . . }
    public void add(E element) { . . . }
    public E remove0{ . . }
    public int size() { . . . }
    private E[] elements;
}
 
public class LinkedListQueue<E> implements Queue<E> //not an actual library class
{
    private Link head;
    private Link tail;
    LinkedListQueue(){ . . . }
    public void add(E element) { . ..}
    public E remove() {.. . }
    public int size() { . . . }
}
```

实际上，Java中并没有上面例子中的`CircularArrayQueue`和`LinkedListQueue`这两个类，这里只是作为例子阐述实现方式上的不同。在Java中，如果需要一个循环数组队列，可以使用`ArrayDeque`类。如果需要一个链表队列，就直接使用`LinkedList`类，这个类实现了`Queue`接口。

```java
public class ArrayDeque<E> extends AbstractCollection<E> implements Deque<E>, Cloneable, Serializable
```

```java
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable
```

当在程序中使用队列时，一旦构建了集合就不需要知道究竟使用了哪种实现。因此，只有在构建集合对象时，使用具体的类才有意义。可以使用接口类型存放集合的引用。

```java
Queue<Customer>expresslane = new CircularArrayQueue<>(100);
expressLane.add(new Customer("Harry"));
```

利用这种方式，一旦改变了想法，可以轻松地使用另外一种不同的实现。只需要对程序的一个地方做出修改，即调用构造器的地方。如果觉得`LinkedListQueue`是个更好的选择，就将代码修改为：

```java
Queue<Custoaer> expressLane = new LinkedListQueueo();
expressLane.addCnew CustonierC'Harry"));
```

为什么选择这种实现，而不选择那种实现呢？接口本身并不能说明哪种实现的效率究竟如何。循环数组要比链表更高效，因此多数人优先选择循环数组。然而，通常这样做也需要付出一定的代价。

循环数组是一个有界集合，即容量有限。如果程序中要收集的对象数量没有上限，就最好使用链表来实现。

在研究API文档时，会发现另外一组名字以`Abstract`开头的类，例如，`AbstractQueue`。这些类是为类库实现者而设计的。如果想要实现自己的队列类（也许不太可能)，会发现扩展`AbstractQueue`类要比实现`Queue`接口中的所有方法轻松得多。

```java
public abstract class AbstractQueue<E> extends AbstractCollection<E> implements Queue<E> {
    protected AbstractQueue() { }
    public boolean add(E e) { }
    public E remove() { }
    public E element() { }
    public void clear() { }
    public boolean addAll(Collection<? extends E> c) { }
}
```



#### 9.1.2 Collection接口

在Java类库中，集合类的基本接口是`Collection`接口。这个接口有两个基本方法：

```java
public interface Collection<E> extends Iterable<E> {
    boolean add(E element);
    Iterator<E> iterator();
}
```

除了这两个方法之外，还有几个方法，将在稍后介绍。

`add`方法用于向集合中添加元素。如果添加元素确实改变了集合就返回`true`,如果集合没有发生变化就返回`false`。例如，如果试图向集中添加一个对象，而这个对象在集中已经存在，这个添加请求就没有实效，因为集中不允许有重复的对象。

`iterator`方法用于返回一个实现了`Iterator`接口的对象。可以使用这个迭代器对象依次访问集合中的元素。



#### 9.1.3 迭代器

Iterator接口包含 4个方法：

```java
public interface Iterator<E>
{
    E next();
    booleanhasNext();
    void remove();
    default void forEachRemaining(Consumer<? super E> action);
}
```

通过反复调用`next`方法，可以逐个访问集合中的每个元素。但是，如果到达了集合的末尾，`next`方法将抛出一个`NoSuchElementException`。因此，需要在调用next之前调用`hasNext`方法。如果迭代器对象还有多个供访问的元素，这个方法就返回`true`。如果想要査看集合中的所有元素，就请求一个迭代器，并在`hasNext`返回`true`时反复地调用`next`方法。例如：

```java
Collection<String> c = . . .;
Iterator<String> iter = c.iterator();
while (iter.hasNext())
{
    String element = iter.next();
    do some thing with element
}
```

用“for each”循环可以更加简练地表示同样的循环操作：

```java
for (String element : c)
{
    do some thing with element
}
```

编译器简单地将“for each”循环翻译为带有迭代器的循环。

“for each”循环可以与任何实现了`Iterable`接口的对象一起工作，这个接口只包含一个抽象方法：

```java
public interface Iterable<E>
{
    Iterator<E> iterator();
    ...
}
```

`Collection`接口扩展了`Iterable`接口。因此，对于标准类库中的任何集合都可以使用“for each”循环。

在JavaSE8中，甚至不用写循环。可以调用`forEachRemaining`方法并提供一lambda表达式（它会处理一个元素）。将对迭代器的每一个元素调用这个`lambda`表达式，直到再没有元素为止。

```java
iterator.forEachRemaining(element -> dosomethingwith element);
```

元素被访问的顺序取决于集合类型。如果对`ArrayList`进行迭代，迭代器将从索引`0`开始，每迭代一次，索引值加`1`然而，如果访问`HashSet`中的元素，每个元素将会按照某种随机的次序出现。虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。这对于计算总和或统计符合某个条件的元素个数这类与顺序无关的操作来说，并不是什么问题。

Java迭代器查找一个元素的唯一方法是调用`next`,而在执行查找操作的同时，迭代器的位置随之向前移动。因此，应该将Java迭代器认为是位于两个元素之间。当调用`next`时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。

![img](https://img-blog.csdnimg.cn/20200417210240937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1p6ZWhhbzEx,size_16,color_FFFFFF,t_70)

`Iterator`接口的`remove`方法将会删除上次调用`next`方法时返回的元素。在大多数情况下，在决定删除某个元素之前应该先看一下这个元素是很具有实际意义的。然而，如果想要删除指定位置上的元素，仍然需要越过这个元素。例如，下面是如何删除字符串集合中第一个元素的方法：

```java
Iterator<String> it = c.iterator();
it.next();// skip over the first element
it.remove(); //now remove it
```

更重要的是，对`next`方法和`remove`方法的调用具有互相依赖性。如果调用`remove`之前没有调用`next`将是不合法的。如果这样做，将会抛出一个`IllegalStateException`异常。

如果想删除两个相邻的元素，不能直接地这样调用：

```java
it.remove();
it.remove();//Error!
```

相反地，必须先调用next越过将要删除的元素。

```java
it,remove();
it.next();
it.remove(); //OK
```



#### 9.1.4 泛型实用方法

当然，如果实现`Collection`接口的每一个类都要提供如此多的例行方法将是一件很烦人的事情。为了能够让实现者更容易地实现这个接口，Java类库提供了一个类`AbstractCollection`，它将基础方法`size`和`iterator`抽象化了，但是在此提供了例行方法。例如：

```java
public abstract class AbstractCollection<E> implements Collection<E>
{
    public abstract Iterator<E> iterator();
    public boolean contains(Object obj)
    {
        for (E element : this)//calls iterator()
            if (element,equals(obj))
                return=true;
        return false;
    }
    ...
}
```

此时，一个具体的集合类可以扩展`AbstractCollection`类了。现在要由具体的集合类提供`iterator`方法，而`contains`方法已由`AbstractCollection`超类提供了。然而，如果子类有更加有效的方式实现`contains`方法，也可以由子类提供，就这点而言，没有什么限制。

对于Java SE8,这种方法有些过时了。如果这些方法是`Collection`接口的默认方法会更好。但实际上并不是这样。不过，确实已经增加了很多默认方法。其中大部分方法都与流的处理有关。另外，还有一个很有用的方法：

```java
default boolean removelf(Predicate<? super E> filter)
```

这个方法用于删除满足某个条件的元素。
