## 第5章 继承

继承的基本思想是：可以基于已有的类创建新的类。继承已存在的类就是复用这些类的方法，而且可以增加一些新的方法和字段，使新的类能够适应新的情况。

### 5.1 类，超类和子类

在设计类的时候，应该将最一般的方法放在超类中，而将更特殊的方法放在子类中。

#### 5.1.3 子类构造器

使用`super`调用父类构造器的语句必须是子类构造器的第一条语句。

如果子类的构造器没有显示地调用超类的构造器，将自动地调用超类的无参构造。如果超类没有无参构造，并且在子类的构造器中又没有显示地调用超类的其他构造器，Java编译器就会报告一个错误。

`super`关键字有两个含义：一是调用超类的方法，二是调用超类的构造方法。



#### 5.1.5 多态

`"is-a"`规则的另一种表述是**替换原则**。它指出程序中出现超类对象的任何地方都可以使用子类对象替换。

在Java中，对象变量是多态的。一个`Employee`类型的变量既可以引用一个`Employee`类型的对象，也可以引用`Employee`类的任何一个子类的对象。



#### 5.1.7 阻止继承：final类和方法

**类前使用final：**不允许该类再被继承，派生。

```java
public final class Executive extends Manager{
	....
}
```

**方法前使用final：**子类就不能覆盖这个方法（final类中的所有方法自动地成为final方法）

```java
public class Employee{
    ...
    public final String getName() {
        return "hello";
    }
}
```

**字段前使用final：**构造对象之后值不能改变（final类中的字段**不是**final的哦！）



#### 5.1.9 抽象类

从某种角度看，如果一个类将它作为派生其他类的基类，而不是用来构造特定的实例时，说明这个类需要是一个抽象类。

为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。

```java
public abstract class Person {
    public abstract String getDescription();
}
```

除了抽象方法之外，**抽象类还可以包含字段和具体方法**。

抽象类不能**实例化**。扩展抽象类可以有两种选择。一种是在子类中保留抽象类中的部分或者所以抽象方法仍未定义，这样就必须将子类也标记为抽象类；另一种做法就是定义全部方法，这样一来，子类就不是抽象的了。



#### 5.1.10 受保护访问

1. `protected`只能由同一个包中的类访问。**受保护部分对所有子类（尽管不在同一包下）及同一个包中的所有其他类都可见。**
2. `private`仅对本类可见。子类都不可以。
3. `public`对外部完全可见。
4. 不加修饰符，对本包可见。



### 5.2 Object：所有类的超类

在Java中，只有**基本类型**不是对象（数值，字符，布尔）。所有的数组类，**不管是对象数组还是基本类型的数组都扩展了`Object`类！**

#### 5.2.2 equals方法

用于确定一个对象是否等于另外一个对象。确定两个对象引用是否相等。经常需要基于状态检测对象的相等性，如果两个对象有相同的状态，才认为这两个对象是相等的。否则没多大意义。所以下面代码重写了`Employee`的`equals`方法。如果`id`，`salary`，`name`都相等，那么两个对象就相等。

下面是标准的`equals`方法：注意函数签名中传入的参数是`Object`对象，因为是`Object`中的方法。

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Employee employee = (Employee) o;
    return id == employee.id && Double.compare(employee.salary, salary) == 0 && Objects.equals(name, employee.name);
}
```

`equals`与~的定义必须相容：如果`x.equals(y)`返回`true`，那么`x.hashcode()`就必须与`y.hashcode()`返回相同的值。



### 5.4 对象包装器与自动装箱

**包装器类是 不可变的，即一旦构造了包装器，就不允许更改包装器在其中的只能。同时，包装器类还是final的。**

由于每个值分别包装在对象中，所以`ArrayList<Integer>`的效率远远低于`int[]`数组。但是很容易向其中加入`int`类型的元素。

```java
list.add(3);
```

将自动地变换为

```java
list.add(Integer.valueOf(3));
```

这种变换成为**自动装箱**。

最后强调一下，装箱与拆箱是编译器要做的事儿，而不是虚拟机。

`Integer`类中的一些`API`对比：

```java
// 返回一个数值型整数
static int parseInt(String s);
// 返回一个Integer对象
static Integer valueOf(String s);
```



### 5.6 枚举类
