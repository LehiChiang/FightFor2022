## 设计模式的定义

设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定制的解决方案，该方案描述了对象和类之间的相互作用。



## 设计模式的基本要素

模式名称，问题，目的，解决方案，效果，案例代码和相关设计模式。



## 设计模式的分类

1. 根据目的分类
   - 创建型(Creational)：**创造型模式主要用于创建对象**，GoF提供了5中创建型模式，分别是**工厂方法模式**，**抽象工厂模式**，**建造者模式**，**原型模式**和**单例模式**。
   - 结构型(Structural)：**结构型模式主要处理类或对象的组合**，GoF提供了7种结构型模式，分别是**适配器模式**，桥接模式，**组合模式**，**装饰模式**，**外观模式**，**享元模式**，**代理模式**。
   - 行为型(Behavioral)：**行为型模式主要用于处理类或对象怎么样交互和怎么样分配职责**，GoF提供了11种行为型模式，分别是**责任链模式**，**命令模式**，**解释器模式**，**迭代器模式**，**中介者模式**，**备忘录模式**，**观察者模式**，**状态模式**，**策略模式**，**模板方法模式**和**访问者模式**。
2. 根据范围分类
   - 类模式：处理类和子类之间的关系，这些关系通过继承建立，在编译时就被确定下来，是一种静态关系。
   - 对象模式：处理对象间的关系，这些关系在运行时变化，更具有动态性。



## 面向对象设计原则

| 设计原则名称                                   | 定义                                                         | 使用频率 |
| ---------------------------------------------- | ------------------------------------------------------------ | -------- |
| 单一职责原则 (Single Responsibility Principle) | 一个对象应该只包含一个职责，并且该职责被完整地封装在一个类中。这个原则是实现高内聚低耦合的方针。提高程序代码的复用性。 | 4        |
| 开闭原则 (Open-Closed Principle)               | 软件实体应对扩展开放，对修改关闭。                           | 5        |
| 里氏替换原则 (Principle)                       | 所有引用父类对象的地方都必须可以正确地替换成他的子类对象，并且运行不会出错，反过来则不成立。在程序中尽量使用父类类型对对象进行定义，而在运行时再确定其子类类型。可以将父类设计成接口或者抽象类来实现里氏替换原则。 | 5        |
| 依赖倒转原则 (Principle)                       | 高层次模块不应该依赖于低模块，他们都应该依赖于抽象。细节应该依赖于抽象。面向抽象类或者接口编程！开闭原则是实现目标，里氏替换原则是基础，那么依赖倒转就是实现方法。 | 5        |
| 接口隔离原则 (Principle)                       | 当一个接口过大时应将其分成更小的接口，使客户端知道与之相关的接口即可。同时这样也符合单一责任原则，减少无用代码。 | 5        |
| 合成复用原则 (Principle)                       | 应优先考虑使用对象组合的方式，而不是通过继承来实现复用的目的。因为通过继承来服用可能会违背开闭原则，破坏程序的封闭性。 | 5        |
| 迪米特法则 (Principle)                         | 在设计系统时应该减少对象之间的交互，一个对象只能和“朋友”交互，和“非朋友”交互就需要中间者。 | 5        |



## 简单工厂模式

### 定义

**简单工厂模式(Simple Factory Pattern)**：**定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。**



### 角色

- Factory（工厂角色）

- Product（抽象产品角色）
- ConcreteProduct（具体产品角色）



### 结构

<img src="imgs\image-20220322224338076.png" alt="image-20220322224338076" style="zoom:67%;" />

### 优点

- 实现了对象创建和使用的分离

- 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可

- 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性



### 缺点

- 工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响**

- 增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度

- 系统扩展困难，一旦添加新产品不得不修改工厂逻辑

- 由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构，工厂类不能得到很好地扩展



### 适用环境

- 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂

- 客户端只知道传入工厂类的参数，对于如何创建对象并不关心



## 工厂方法模式

### 定义

定义一个用于创建对象的接口，但是**让子类决定将哪一个类实例化**。工厂方法模式让一个类的实例化**延迟到其子类**。工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象。



### 角色

- Product（抽象产品）
- ConcreteProduct（具体产品）
- Factory（抽象工厂）
- ConcreteFactory（具体工厂）



### 结构

<img src="imgs\image-20220322230029824.png" alt="image-20220322230029824" style="zoom:67%;" />

### 优点

- 工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节

- 能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部

- 在系统中加入新产品时，完全符合开闭原则



### 缺点

- 系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，会给系统带来一些额外的开销

- 增加了系统的抽象性和理解难度



## 抽象工厂模式

### 定义

提供一个**创建一系列相关或相互依赖对象的接口**，而无须指定它们具体的类。



### 角色

- AbstractFactory（抽象工厂）
- ConcreteFactory（具体工厂）
- AbstractProduct（抽象产品）
- ConcreteProduct（具体产品）



### 结构

<img src="imgs\image-20220322231343853.png" alt="image-20220322231343853" style="zoom: 80%;" />





### 优点

- 隔离了具体类的生成，使得客户端并不需要知道什么被创建

- 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象

- 增加新的产品族很方便，无须修改已有系统，符合开闭原则



### 缺点

增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则



### 适用环境

- 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节

- 系统中有多于一个的产品族，但每次只使用其中某一产品族

- 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来

- 产品等级结构稳定，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构



## 建造者模式

### 定义

将一个**复杂对象的构建与它的表示分离**，使得同样的构建过程可以创建不同的表示。**将客户端与包含多个部件的复杂对象的创建过程分离，**客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可.



### 角色

- Builder（抽象建造者）
- ConcreteBuilder（具体建造者）
- Product（产品）
- Director（指挥者）



### 结构

<img src="imgs\image-20220322233126554.png" alt="image-20220322233126554" style="zoom:67%;" />

### 代码实现

产品类

```java
public class Product {
	private String partA; //定义部件，部件可以是任意类型，包括值类型和引用类型
	private String partB;
	private String partC;

	//partA的Getter方法和Setter方法省略
	//partB的Getter方法和Setter方法省略
	//partC的Getter方法和Setter方法省略
}
```

抽象建造者类

```java
public abstract class Builder {
    //创建产品对象
   protected Product product=new Product();
    public abstract void buildPartA();
    public abstract void buildPartB();
    public abstract void buildPartC();
	
    //返回产品对象
    public Product getResult() {
        return product;
    }
}
```

具体建造者类

```java
public class ConcreteBuilder1 extends Builder{
    public void buildPartA() {
        product.setPartA("A1");
    }

    public void buildPartB() {
        product.setPartB("B1");
    }

    public void buildPartC() {
        product.setPartC("C1");
    }
}
```

指挥者类

```java
public class Director {
    private Builder builder;
	
    public Director(Builder builder) {
        this.builder=builder;
    }
	
    public void setBuilder(Builder builder) {
        this.builder=builer;
    }
	
    //产品构建与组装方法
    public Product construct() {
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
        return builder.getResult();
    }
}
```



### 优点

- 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象

- 每一个具体建造者都相对独立，与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，扩展方便，符合开闭原则

- 可以更加精细地控制产品的创建过程



### 缺点

- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，不适合使用建造者模式，因此其使用范围受到一定的限制

- 如果产品的内部变化复杂，可能会需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加了系统的理解难度和运行成本



### 适用环境

- 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量

- 需要生成的产品对象的属性相互依赖，需要指定其生成顺序

- 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中

- 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品



## 原型模式

### 定义

使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。

工作原理：要发动创建的对象通过请求原型对象复制自己来实现创建过程, 创建新对象（也称为克隆对象）的工厂就是原型类自身，工厂方法由负责复制原型对象的克隆方法来实现

通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，每一个克隆对象都是独立的



### 角色

- Prototype（抽象原型类）

- ConcretePrototype（具体原型类）

- Client（客户类）



### 结构

<img src="imgs\image-20220322234806242.png" alt="image-20220322234806242" style="zoom: 67%;" />

### 优点

- 简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率
- 扩展性较好
- 提供了简化的创建结构，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品
- 可以使用深克隆的方式保存对象的状态，以便在需要的时候使用，可辅助实现撤销操作



### 缺点

- 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了开闭原则
- 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦



### 适用环境

- 创建新对象成本较大，新对象可以通过复制已有对象来获得，如果是相似对象，则可以对其成员变量稍作修改
- 系统要保存对象的状态，而对象的状态变化很小
- 需要避免使用分层次的工厂类来创建分层次的对象
- Ctrl + C -> Ctrl + V



## 单例模式

### 定义

确保一个类**只有一个实例**，并提供一个**全局访问点**来访问这个唯一实例。

某个类**只能有一个实例**

必须**自行创建这个实例**

必须**自行向整个系统提供这个实例**



### 角色

- Singleton（单例）



### 结构

<img src="imgs\image-20220322235931677.png" alt="image-20220322235931677" style="zoom:67%;" />

### 代码实现

```java
public class LazySingleton { 
    private volatile static LazySingleton instance = null; 

    private LazySingleton() { } 

    public static LazySingleton getInstance() { 
        //第一重判断
        if (instance == null) {
            //锁定代码块
            synchronized (LazySingleton.class) {
                //第二重判断
                if (instance == null) {
                    instance = new LazySingleton(); //创建单例实例
                }
            }
        }
        return instance; 
    }
}
```



### 两种单例模式的比较

饿汉式单例类：无须考虑多个线程同时访问的问题；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；系统加载时间可能会比较长

懒汉式单例类：实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响



### 优点

- 提供了对唯一实例的受控访问
- 可以节约系统资源，提高系统的性能



### 缺点

- 扩展困难（缺少抽象层）
- 单例类的职责过重
- 由于自动垃圾回收机制，可能会导致共享的单例对象的状态丢失



### 适用环境

- 系统只需要一个实例对象，或者因为资源消耗太大而只允许创建一个对象

- 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例
